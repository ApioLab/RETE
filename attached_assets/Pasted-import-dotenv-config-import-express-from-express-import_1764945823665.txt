import "dotenv/config";
import express from "express";
import cors from "cors";
import { ethers } from "ethers";

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static("public"));


app.set("json replacer", (k, v) => (typeof v === "bigint" ? v.toString() : v));

const {
    RPC_URL,
    PRIVATE_KEY,
    FACTORY_ADDRESS,
    BURN_MODE = "cap",
    TRANSFER_MODE = "cap"
} = process.env;

if (!RPC_URL || !PRIVATE_KEY) {
    throw new Error("RPC_URL or PRIVATE_KEY missing");
}

const provider = new ethers.JsonRpcProvider(RPC_URL);
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

const reteTokenAbi = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
  "function owner() view returns (address)",
  "function adminSpender() view returns (address)",
  "function mintPaused() view returns (bool)",
  "function nonces(address) view returns (uint256)",
  "function permit(address owner,address spender,uint256 value,uint256 deadline,uint8 v,bytes32 r,bytes32 s)",
  "function allowance(address,address) view returns (uint256)",
  "function approve(address,uint256) returns (bool)",
  "function transfer(address to, uint256 value) returns (bool)",
  "function transferFrom(address from,address to,uint256 value) returns (bool)",
  "function mint(address to, uint256 amount)",
  "function setMintPaused(bool paused)",
  "function burnFrom(address account,uint256 amount)",

  // mint gasless
  "function mintNonces(address) view returns (uint256)",
  "function mintWithSig(address signer,address to,uint256 amount,uint256 deadline,uint8 v,bytes32 r,bytes32 s)",

  // burn gasless del Coordinatore
  "function burnNonces(address) view returns (uint256)",
  "function burnWithSig(address signer,address from,uint256 amount,uint256 deadline,uint8 v,bytes32 r,bytes32 s)",

  // opzionali admin burn on chain
  "function adminBurnEnabled() view returns (bool)",
  "function toggleAdminBurn(bool enabled)",
  "function adminBurn(address from, uint256 amount)",
  "function adminBatchBurn(address[] holders, uint256[] amounts)"
];

const factoryAbi = [
    "event ReteTokenCreated(address indexed token, address indexed coordinator, address indexed adminSpender, string name, string symbol)",
    "function createReteToken(string name_, string symbol_, address coordinatorOwner, address adminSpender_) returns (address)",
    "function getAllTokens() view returns (address[])",
    "function getCoordinatorTokens(address coordinator) view returns (address[])"
];

function tokenAt(address) {
    return new ethers.Contract(address, reteTokenAbi, wallet);
}
function factoryAt(address) {
    return new ethers.Contract(address, factoryAbi, wallet);
}
function parseAmount(human, decimals) {
    return ethers.parseUnits(String(human), Number(decimals));
}

app.post("/factory/create", async (req, res) => {
    try {
        const { factoryBytecode } = req.body;
        if (!factoryBytecode) return res.status(400).json({ error: "factoryBytecode required" });
        const tx = await wallet.sendTransaction({ data: factoryBytecode });
        const rcpt = await tx.wait();
        res.json({ tx: tx.hash, contractAddress: rcpt.contractAddress });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/factory/createReteToken", async (req, res) => {
    try {
        const { name, symbol, coordinatorOwner, adminSpender, factoryAddress = FACTORY_ADDRESS } = req.body;
        if (!name || !symbol || !coordinatorOwner || !adminSpender || !factoryAddress) {
            return res.status(400).json({ error: "name symbol coordinatorOwner adminSpender factoryAddress required" });
        }
        const f = factoryAt(factoryAddress);
        const tx = await f.createReteToken(name, symbol, coordinatorOwner, adminSpender);
        const rcpt = await tx.wait();
        let created = null;
        for (const log of rcpt.logs) {
            try {
                const parsed = f.interface.parseLog(log);
                if (parsed?.name === "ReteTokenCreated") {
                    created = parsed.args.token;
                    break;
                }
            } catch { }
        }
        res.json({ tx: tx.hash, token: created });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.get("/factory/all", async (req, res) => {
    try {
        const f = factoryAt(req.query.factoryAddress || FACTORY_ADDRESS);
        const tokens = await f.getAllTokens();
        res.json({ tokens });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.get("/factory/by-coordinator/:addr", async (req, res) => {
    try {
        const f = factoryAt(req.query.factoryAddress || FACTORY_ADDRESS);
        const list = await f.getCoordinatorTokens(req.params.addr);
        res.json({ coordinator: req.params.addr, tokens: list });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.get("/token/:token/config", async (req, res) => {
  try {
    const t = tokenAt(req.params.token);
    const net = await provider.getNetwork(); // aggiunta
    const [name, symbol, decimals, totalSupply, owner, adminSp, mintPaused, adminBurnEnabled] = await Promise.all([
      t.name(),
      t.symbol(),
      t.decimals(),
      t.totalSupply(),
      t.owner(),
      t.adminSpender(),
      t.mintPaused(),
      t.adminBurnEnabled()
    ]);
    res.json({
      token: req.params.token,
      name,
      symbol,
      decimals: Number(decimals),
      totalSupply: totalSupply.toString(),
      owner,
      adminSpender: adminSp,
      mintPaused: Boolean(mintPaused),
      adminBurnEnabled: Boolean(adminBurnEnabled),
      chainId: Number(net.chainId) // aggiunta
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});


app.get("/token/:token/balance/:addr", async (req, res) => {
    try {
        const t = tokenAt(req.params.token);
        const bal = await t.balanceOf(req.params.addr);
        res.json({ token: req.params.token, address: req.params.addr, balance: bal.toString() });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

async function assertIsOwner(t) {
    const o = await t.owner();
    if (o.toLowerCase() !== wallet.address.toLowerCase()) {
        throw new Error("Server wallet is not token owner");
    }
}

app.post("/token/:token/mint", async (req, res) => {
    try {
        const { to, amountHuman } = req.body;
        const t = tokenAt(req.params.token);
        await assertIsOwner(t);
        const decimals = Number(await t.decimals());
        const amount = parseAmount(amountHuman, decimals);
        const tx = await t.mint(to, amount);
        const rcpt = await tx.wait();
        res.json({ tx: tx.hash, block: rcpt.blockNumber, to, amount: amount.toString() });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/mint-with-sig", async (req, res) => {
    try {
        const { signer, to, amountHuman, deadline, v, r, s } = req.body;
        if (!signer || !to || !amountHuman || !deadline || v === undefined || !r || !s) {
            return res.status(400).json({ error: "missing fields" });
        }
        const t = tokenAt(req.params.token);
        const net = await provider.getNetwork();

        const decimals = Number(await t.decimals());
        const amount = ethers.parseUnits(String(amountHuman), decimals);
        const tx = await t.mintWithSig(signer, to, amount, deadline, v, r, s);
        const rcpt = await tx.wait();
        res.json({ tx: tx.hash, block: rcpt.blockNumber, to, amount: amount.toString(), signer, deadline });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/set-mint-paused", async (req, res) => {
    try {
        const { paused } = req.body;
        const t = tokenAt(req.params.token);
        await assertIsOwner(t);
        const tx = await t.setMintPaused(Boolean(paused));
        const rcpt = await tx.wait();
        res.json({ tx: tx.hash, block: rcpt.blockNumber, paused: Boolean(paused) });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/toggle-admin-burn", async (req, res) => {
    try {
        const { enabled } = req.body;
        const t = tokenAt(req.params.token);
        await assertIsOwner(t);
        const tx = await t.toggleAdminBurn(Boolean(enabled));
        const rcpt = await tx.wait();
        res.json({ tx: tx.hash, block: rcpt.blockNumber, enabled: Boolean(enabled) });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/burn-with-sig", async (req, res) => {
  try {
    const { signer, from, amountHuman, deadline, v, r, s } = req.body;
    if (!signer || !from || !amountHuman || !deadline || v === undefined || !r || !s) {
      return res.status(400).json({ error: "missing fields" });
    }
    const t = tokenAt(req.params.token);
    const decimals = Number(await t.decimals());
    const amount = ethers.parseUnits(String(amountHuman), decimals);
    const tx = await t.burnWithSig(signer, from, amount, deadline, v, r, s);
    const rcpt = await tx.wait();
    res.json({
      action: "burn-with-sig",
      tx: tx.hash,
      block: rcpt.blockNumber,
      signer,
      from,
      amount: amount.toString(),
      deadline
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});


app.post("/token/:token/permit-transfer", async (req, res) => {
    try {
        const { owner, spender, value, deadline, v, r, s, recipient } = req.body;
        if (!owner || !spender || !value || !deadline || v === undefined || !r || !s || !recipient) {
            return res.status(400).json({ error: "missing fields" });
        }
        if (spender.toLowerCase() !== wallet.address.toLowerCase()) {
            return res.status(400).json({ error: "spender must be server wallet" });
        }
        const t = tokenAt(req.params.token);

        const txPermit = await t.permit(owner, spender, value, deadline, v, r, s);
        const rcptPermit = await txPermit.wait();

        const allowance = await t.allowance(owner, wallet.address);
        if (allowance === 0n) return res.status(400).json({ error: "no allowance after permit" });

        const requested = BigInt(value);
        const mode = String(TRANSFER_MODE).toLowerCase();
        if (mode === "reject" && requested > allowance) {
            return res.status(400).json({ error: "requested over allowance", requested: requested.toString(), allowance: allowance.toString() });
        }
        const sendAmount = requested <= allowance ? requested : allowance;

        const tx = await t.transferFrom(owner, recipient, sendAmount);
        const rcpt = await tx.wait();
        const left = await t.allowance(owner, wallet.address);

        res.json({
            action: "permit-transfer",
            sent: sendAmount.toString(),
            allowanceAfter: left.toString(),
            permitTx: txPermit.hash,
            permitBlock: rcptPermit.blockNumber,
            transferTx: tx.hash,
            transferBlock: rcpt.blockNumber
        });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/permit-burn", async (req, res) => {
    try {
        const { owner, spender, value, deadline, v, r, s } = req.body;
        if (!owner || !spender || !value || !deadline || v === undefined || !r || !s) {
            return res.status(400).json({ error: "missing fields" });
        }
        if (spender.toLowerCase() !== wallet.address.toLowerCase()) {
            return res.status(400).json({ error: "spender must be server wallet" });
        }
        const t = tokenAt(req.params.token);

        const txPermit = await t.permit(owner, spender, value, deadline, v, r, s);
        const rcptPermit = await txPermit.wait();

        const allowance = await t.allowance(owner, wallet.address);
        if (allowance === 0n) return res.status(400).json({ error: "no allowance after permit" });

        const requested = BigInt(value);
        const mode = String(BURN_MODE).toLowerCase();
        if (mode === "reject" && requested > allowance) {
            return res.status(400).json({ error: "requested over allowance", requested: requested.toString(), allowance: allowance.toString() });
        }
        const burnAmount = requested <= allowance ? requested : allowance;

        const tx = await t.burnFrom(owner, burnAmount);
        const rcpt = await tx.wait();
        const left = await t.allowance(owner, wallet.address);

        res.json({
            action: "permit-burn",
            burned: burnAmount.toString(),
            allowanceAfter: left.toString(),
            permitTx: txPermit.hash,
            permitBlock: rcptPermit.blockNumber,
            burnTx: tx.hash,
            burnBlock: rcpt.blockNumber
        });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/admin-burn", async (req, res) => {
    try {
        const { from, amountHuman } = req.body;
        const t = tokenAt(req.params.token);
        await assertIsOwner(t);
        const decimals = Number(await t.decimals());
        const amount = parseAmount(amountHuman, decimals);
        const tx = await t.adminBurn(from, amount);
        const rcpt = await tx.wait();
        res.json({ action: "admin-burn", tx: tx.hash, block: rcpt.blockNumber, from, amount: amount.toString() });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/admin-batch-burn", async (req, res) => {
    try {
        const { holders, amountsHuman } = req.body;
        const t = tokenAt(req.params.token);
        await assertIsOwner(t);
        if (!Array.isArray(holders) || !Array.isArray(amountsHuman) || holders.length !== amountsHuman.length) {
            return res.status(400).json({ error: "invalid arrays" });
        }
        const decimals = Number(await t.decimals());
        const amounts = amountsHuman.map(x => parseAmount(x, decimals));
        const tx = await t.adminBatchBurn(holders, amounts);
        const rcpt = await tx.wait();
        res.json({ action: "admin-batch-burn", tx: tx.hash, block: rcpt.blockNumber, holders, amounts: amounts.map(a => a.toString()) });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/token/:token/transfer", async (req, res) => {
    try {
        const { to, amountHuman } = req.body;
        const t = tokenAt(req.params.token);
        const decimals = Number(await t.decimals());
        const amount = parseAmount(amountHuman, decimals);
        const tx = await t.transfer(to, amount);
        const rcpt = await tx.wait();
        res.json({ tx: tx.hash, block: rcpt.blockNumber, to, amount: amount.toString() });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

const port = Number(process.env.PORT || 3000);
app.listen(port, () => {
    console.log(`Server listening on http://localhost:${port}`);
});
